%% DreamTask: Oddball Version
function [maintask, list] = dreamOddballConfig()
%% Housekeeping
%Setting up the screen
sc=dotsTheScreen.theObject;
sc.reset('displayIndex', 2); %change display index to 0 for debug. 1 for full screen. Use >1 for external monitors.

%Call GetSecs just to load up the Mex files for getting time, so no delays
%later
GetSecs;

%% Setting up a list structure
list = topsGroupedList;

%Oddball Task Parameters
trials = 100;
interval = 3; %intertrial interval
standardf = 500; %standard frequency
oddf = 700; %oddball frequency
p_odd = 0.25; %probability of oddball freq

list{'Stimulus'}{'StandardFreq'} = standardf;
list{'Stimulus'}{'OddFreq'} = oddf;
list{'Stimulus'}{'ProbabilityOdd'} = p_odd;

%Subject ID
subj_id = input('Subject ID: ','s');

%Sound player
player = dotsPlayableNote();
player.duration = 0.5; %sound duration in seconds
player.intensity = 0.7;
player.ampenv = tukeywin(player.sampleFrequeny*player.duration);

%Input parameters
reactionwindow = 1; %Intertrial interval MUST be larger than this number for task to be robust
responsepattern = [4, 4, 4, 4, 4]; %Pattern is right trigger-pull 5 times

list{'Input'}{'ReactionWindow'} = reactionwindow;
list{'Input'}{'ResponsePattern'} = responsepattern;

%Data Storage
list{'Stimulus'}{'Counter'} = 0;
list{'Stimulus'}{'Playtimes'} = zeros(1,trials); %Store sound player timestamps 
list{'Stimulus'}{'Playfreqs'} = zeros(1,trials); %Store frequencies played
%% Input
gp = dotsReadableHIDGamepad(); %Set up gamepad object
if gp.isAvailable
    % use the gamepad if connected
    ui = gp;
   
    % define movements, which must be held down
    %   map x-axis -1 to left and +1 to right
    isLeft = [gp.components.ID] == 7;
    isA = [gp.components.ID] == 3;
    isRight = [gp.components.ID] == 8;
    
    Left = gp.components(isLeft);
    A = gp.components(isA);
    Right = gp.components(isRight);
    
    gp.setComponentCalibration(Left.ID, [], [], [0 +2]);
    gp.setComponentCalibration(A.ID, [], [], [0 +3]);
    gp.setComponentCalibration(Right.ID, [], [], [0 +4]);
    
    % undefine any default events
    IDs = gp.getComponentIDs();
    for ii = 1:numel(IDs)
        gp.undefineEvent(IDs(ii));
    end
    
    %Define values for button presses
    gp.defineEvent(Left.ID, 'left', 0, 0, true);
    gp.defineEvent(A.ID, 'continue', 0, 0, true);
    gp.defineEvent(Right.ID, 'right', 0, 0, true);

else

   kb = dotsReadableHIDKeyboard(); %Use keyboard as last resort
    
    % define movements, which must be held down
    %   Left = +2, Up = +3, Right = +4
    isLeft = strcmp({kb.components.name}, 'KeyboardF');
    isA = strcmp({kb.components.name}, 'KeyboardW');
    isRight = strcmp({kb.components.name}, 'KeyboardJ');

    LeftKey = kb.components(isLeft);
    UpKey = kb.components(isA);
    RightKey = kb.components(isRight);
    
    kb.setComponentCalibration(LeftKey.ID, [], [], [0 +2]);
    kb.setComponentCalibration(UpKey.ID, [], [], [0 +3]);
    kb.setComponentCalibration(RightKey.ID, [], [], [0 +4]);
    
    % undefine any default events
    IDs = kb.getComponentIDs();
    for ii = 1:numel(IDs)
        kb.undefineEvent(IDs(ii));
    end
    
    % define events, which fire once even if held down
    % pressing w a d keys is a 'choice' event
    kb.defineEvent(LeftKey.ID, 'left',  0, 0, true);
    kb.defineEvent(UpKey.ID, 'up',  0, 0, true);
    kb.defineEvent(RightKey.ID, 'right',  0, 0, true);
    
ui = kb;

end

    %Making sure the UI is running on the same clock as everything else!
    %Using Operating System Time as absolute clock, from PsychToolbox
    ui.clockFunction = @GetSecs;

    %Storing ui in a List bin to access from functions!
    ui.isAutoRead = 1;
    list{'Input'}{'Controller'} = ui;

%% Graphics:
% Create some drawable objects. Configure them with the constants above.

list{'graphics'}{'gray'} = [0.25 0.25 0.25];
list{'graphics'}{'fixation diameter'} = 0.4;

    % instruction messages
    m = dotsDrawableText();
    m.color = list{'graphics'}{'gray'};
    m.fontSize = 48;
    m.x = 0;
    m.y = 0;

    % texture -- due to Kamesh
    isoColor1 = [30 30 30];
    isoColor2 = [40 40 40];
    checkerH = 10;
    checkerW = 10;

    checkTexture1 = dotsDrawableTextures();
    checkTexture1.textureMakerFevalable = {@kameshTextureMaker,...
    checkerH,checkerW,[],[],isoColor1,isoColor2};

    % a fixation point
    fp = dotsDrawableTargets();
    fp.isVisible = true;
    fp.colors = list{'graphics'}{'gray'};
    fp.width = list{'graphics'}{'fixation diameter'};
    fp.height = list{'graphics'}{'fixation diameter'};
    list{'graphics'}{'fixation point'} = fp;
    
    %Text prompts
    readyprompt = dotsDrawableText();
    readyprompt.string = 'Ready?';
    readyprompt.fontSize = 42;
    readyprompt.typefaceName = 'Calibri';
    readyprompt.isVisible = false;
    
    buttonprompt = dotsDrawableText();
    buttonprompt.string = 'press the A button to get started';
    buttonprompt.fontSize = 24;
    buttonprompt.typefaceName = 'Calibri';
    buttonprompt.y = -2;
    buttonprompt.isVisible = false;

    %Graphical ensemble
    ensemble = dotsEnsembleUtilities.makeEnsemble('Fixation Point', false);
    texture = ensemble.addObject(checkTexture1);
    ready = ensemble.addObject(readyprompt);
    button = ensemble.addObject(buttonprompt);
    dot = ensemble.addObject(fp);
    
    list{'Graphics'}{'Ensemble'} = ensemble;
    list{'Graphics'}{'Dot Index'} = dot;
    
    % tell the ensembles how to draw a frame of graphics
    %   the static drawFrame() takes a cell array of objects
    ensemble.automateObjectMethod(...
    'draw', @dotsDrawable.drawFrame, {}, [], true);

%SCREEN

    % also put dotsTheScreen into its own ensemble
    screen = dotsEnsembleUtilities.makeEnsemble('screen', false);
    screen.addObject(dotsTheScreen.theObject());

    % automate the task of flipping screen buffers
    screen.automateObjectMethod('flip', @nextFrame);
      
%% Constant Calls
% Read User Interface constant call
readui = topsCallList();
readui.addCall({@read, ui}, 'Read the UI');

% Read eyetracker data constant call
readgaze = topsCallList();
readgaze.addCall({@gazelog, list}, 'Read gaze');

%% Runnables

%STATE MACHINE
Machine = topsStateMachine();
stimList = {'name', 'entry', 'input', 'exit', 'timeout', 'next';
                 'CheckReady', {}, {@checkFixation list}, {}, 0, 'CheckReady';
                 'Stimulus', {@playstim list}, {}, {}, 0, 'Exit';
                 'Exit', {}, {}, {}, interval, ''};
             
Machine.addMultipleStates(stimList);

contask = topsConcurrentComposite();
contask.addChild(ensemble);
contask.addChild(readui);
contask.addChild(readgaze);
contask.addChild(Machine);

maintask = topsTreeNode();
maintask.iterations = trials;
maintask.addChild(contask);
end


%% Accessory Functions
function checkinput(list)
    %import important list objects
    counter = list{'Stimulus'}{'Counter'};
    reactionwindow = list{'Input'}{'ReactionWindow'};
    responsepattern = list{'Input'}{'ResponsePattern'}; 
    ui = list{'Input'}{'Controller'};
    playtimes = list{'Stimulus'}{'Playtimes'};
    
    %get current (playtime) and (playtime + reactionwindow)
    playtime = playtimes(counter);
    stoptime = playtime + reactionwindow;
    
    %Get user input analogs for (playtime) to (playtime + reactionwindow
    uiplaytime = max(ui.history(:,3) < playtime); 
    uistoptime = max(ui.history(:,3) < stoptime); 
    
    %Get all ui.history rows between these times(inclusive)
    history = ui.history(ui.history(:,3) >= playtime && ui.history(:,3) <= stoptime, :);
    
    %get only rows where there are presses
    history = history(history(:,2) > 1, :);
    
    %patternmatch
    width = length(responsepattern);
       
    %Check if the second column contains a matching pattern
    loc_vals = history(:,2);
    for i = 1:length(loc_vals)-width
            loc_idx = i:i+w
            triplet = loc_vals(loc_idx)';
            isPattern = all(triplet == pattern(1,:) | triplet == pattern(2,:));
    end
    
    
    
end

function playstim(list)
    %Adding current iteration to counter
    counter = list{'Stimulus'}{'Counter'};
    counter = counter + 1;
    list{'Stimulus'}{'Counter'} = counter; 
    
    %importing important list objects
    standardf = list{'Stimulus'}{'StandardFreq'};
    oddf = list{'Stimulus'}{'OddFreq'};
    p_odd = list{'Stimulus'}{'ProbabilityOdd'};

    %Dice roll to decide if odd or standard
    roll = rand;
    frequency(roll > p_odd) = standardf;
    frequency(roll <= p_odd) = oddf;

    %Prepping player and playing
    player.frequency = frequency;
    player.prepareToPlay;

    player.play;

    %Logging times and frequencies
    playtimes = list{'Stimulus'}{'Playtimes'};
    playtimes(counter) = player.lastPlayTime;
    list{'Stimulus'}{'Playtimes'} = playtimes;
    
    playfreqs = list{'Stimulus'}{'Playfreqs'};
    playfreqs(counter) = frequency;
    list{'Stimulus'}{'Playfreqs'} = playfreqs;
end

function gazelog(list)
    %Reading gaze
    [lefteye, righteye, timestamp, ~] = tetio_readGazeData;

    %Storing/Organizing data
    if ~isempty(lefteye) || ~isempty(righteye)
    
        leftx = lefteye(:,7); %column 7 is 2D X eye position
        lefty = lefteye(:,8); %column 8 is 2D y eye position
        leftp = lefteye(:,12); %column 12 is eye pupil diameter
        leftv = lefteye(:,13); %this column is validity code

        rightx = righteye(:,7);
        righty = righteye(:,8);
        rightp = righteye(:,12);
        rightv = righteye(:,13);

        list{'Eye'}{'Left'} = [list{'Eye'}{'Left'}; leftx lefty leftp leftv];
        list{'Eye'}{'Right'} = [list{'Eye'}{'Right'}; rightx righty rightp rightv];
        list{'Eye'}{'Time'}= [list{'Eye'}{'Time'}; timestamp];
        list{'Eye'}{'RawTime'} = [list{'Eye'}{'RawTime'}; timestamp];  
        list{'Eye'}{'SynchState'} = [list{'Eye'}{'SynchState'}; tetio_clockSyncState]; 
    end
end

function output = checkFixation(list)
    %Initialize output
    output = 'CheckReady'; %This causes a State Machine loop until fixation is achieved

    %Get parameters for holding fixation
    fixtime = list{'Eye'}{'Fixtime'};

    %Get eye data for left eye
    eyedata = list{'Eye'}{'Left'};
    if ~isempty(eyedata)
        eyedata = eyedata(end-fixtime:end, :); %Cutting data to only the last 'fixtime' time window
        eyeX = eyedata(:,1);
        eyeY = eyedata(:,2);

        %cleaning up signal to let us tolerate blinks
        if any(eyeX > 0) && any(eyeY > 0)
            eyeX(eyeX < 0) = [];
            eyeY(eyeY < 0) = [];
        end

        %Seeing if there's fixation (X Y values between 0.45 and 0.55
        fixX = eyeX > 0.30 & eyeX < 0.70;
        fixY = eyeY > 0.30 & eyeY < 0.70;

        if all(fixY) && all(fixX)
            output = 'Stimulus'; %Send output to get State Machine to produce stimulus
        end
    end

end