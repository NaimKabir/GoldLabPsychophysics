%% Starting Simple
% Dennis and Ian-- you should help out Rishabh and Alice with these basics.

% You all know how to assign variables. I am going to set my 'myvector'
% variable as a vector: which really is just a one dimensional list of
% numbers.

myvector = [0, 1, 2, 3, 4];

%Type out this command in the console (without a semicolon) and see what it 
%does. It should just print out the values stored in 'myvector'.

%When you don't suppress output with a semi-colon, Matlab's natural action
%is just to print out the contents of a variable. Keep that in mind!

%Now we can get started on some concatenation. Concatenation is just
%smushing stuff together.

%'doublevector' below is just myvector smushed into itself. I used a comma,
%which means the vectors will show up side by side. 
doublevector = [myvector, myvector];

%Copy that piece of code into the console without the semicolon to see what
%it looks like.

%In the same vein:
stackedvectors = [myvector; myvector];

%I used a semicolon this time instead! This still smushes the vectors
%together--but this time it stacks them on top of each other instead of
%side by side. Paste that into console to see what it did exactly.

%Note that since 'stackedvectors' isn't just one dimensional anymore (it has
%more than one row and more than one column), it's no longer a vector. It's
%a matrix.

% ASSIGNMENT:
% Write some code below to create a matrix that looks like this:
%[ 0     1     2     3     4    0     1     2     3     4
%  0     1     2     3     4    0     1     2     3     4]


%% Indexing
%Indexing is how you actually pull out values that you need.
%Here's how to think about this:

%Let's look at 'myvector':
doublevector

%We can label each value with a number--as if we're counting. First value
%is 0, second is 1, third is 2, fourth is 3, fifth is 4. 

%So our counting labels will be: (format here is label --> value)
%1 --> 0, 2 --> 1, 3 --> 2, 4 --> 3, 5 --> 4.

%The 'labels' which we assigned are actually the INDEX of that value.
%We can use indices to pull values out of a matrix. 

%For example, if I wanted to pull out a the value '3', I can see that
%that's the 4th value, and thus:
three = myvector(4);

%With matrices, this gets tricker because we have to deal with labeled
%rows as well. So consider 'indexmatrix' below:
indexmatrix = [1 7 8 9 0 10 88 32;
               5 0 98 2 3 55 1024 4];
           
%Here, we can count by row and label them. So:
% Row 1 --> 1 7 8 9 0 10 88 32
% Row 2 --> 5 0 98 2 3 55 1024 4

%And then in each row, we can count from left to right along columns in 
%pretty much the same way as we did with the solo vector!

%So how do we pull out a value? Well, it turns out it's as easy as
%specifying what number row and what number column that value is in
two = indexmatrix(2,4);

%ASSIGNMENT:
%Pull out the value '1024' and store it in a variable called 'biggest'
%////


%////

%Okay, so we know how to pull out stuff. Can we put in stuff?
zeromatrix = zeros(1,8); %This function just created a matrix with 1 row and eight columns of 0s.

%Paste that into the console to see what it looks like.
%Watch what we can do next...
zeromatrix(5) = 12789181;

%Check what that did!

%ASSIGNMENT
%Now, fill up the zeromatrix one by one until it has no zeroes.

%% More indexing!
%The cool thing is, aren't restricted to pulling out single values
%Let's look at that 'indexmatrix' again
indexmatrix

%Let's say I actually wanted to pull out the 7, 9, 10, and 32.
%How could I do that?

%Well, those are all in the first row, and at the 2nd, 4th, 6th, and 8th
%positions. %So I could go:
indexmatrix(1, [2, 4, 6, 8])

%What?! I just used a vector to index a matrix! That's incredible!
%Wait, can I get the 2nd, 4th, 6th, and 8th values for the other row at the
%same time, by also indexing both rows?

% Yes. Take a look at what we get and see if it matched your expectations.
indexmatrix([1 2], [2, 4, 6, 8])

%Also bear in mind here that we only HAVE two rows in index matrix, and we
%indexed rows 1 and 2. But it'd be much simpler to just say I want ALL the
%rows. Is there a way to do that? Yep. 

%Enter the colon. By which I mean the symbol ':', not the anatomical
%feature.
indexmatrix(:, [2 4 6 8])

%That should have given you the same result as above. The colon is actually
%fairly versatile, not only can it act as a stand-in that says 'ALL VALUES,
%PLEASE', but it can delineate ranges.
range = 1:9;
 
%'range' above is the same as 'range2'
range2 = [1 2 3 4 5 6 7 8 9];

%Using the colon, it's just a hell of a lot easier to write.

%Another trick--instead of having to index a range like 3:8 where the
%endpoint is a number, you can just say 3:end, and it will pull out all
%values from 3rd position to the end position. Try that out. 

%ASSIGNMENT:
%Pull out the 2nd through 6th values for both rows in indexmatrix
%//

%//

%% The for-loop

% Let's look at the for loop I have below:
for i = [1 7 5 9 10 8]
    i + 2
end

%Run the loop. What did it do? Well, it spat out the numbers:
% 3, 9, 7, 11, 12, 10

%Here's what the for loop is doing:
%It's going to do the actions in the loop repeatedly, and each time it does
%the action, the variable 'i' will take on a value from the set:
% [1 7 5 9 10 8].
%It will keep going until either it runs out of numbers to use from the
%set, or until it is told to by a command like 'break'

%So on the first iteration i = 1;
%On the second, i = 7;
%On the third, i = 5;
%And so on and so forth...
%Until i = 8, and then the loop ends.

%Inside the for loop, the only action we're doing is just adding 2 and
%outputting the answer.

%So, that being said, does it what it print out make sense?

%ASSIGNMENT:
%Using a for loop and what you know about putting things in vectors using
%indices, fill the below 'zerovector' so that it looks like this:
% zerovector = [ 0 0 0 8 0 12 0 0 18 0 22]
zerovector = [0 0 0 0 0 0 0 0 0 0 0];

%//Your for loop here!


%% More for-loop!

%Yeah, I'm giving you another assignment.
%Given the 'zeromatrix' below, create a zero matrix that looks like this
%using for-loop(s):
%   zeromatrix = [0 0 0 0;
%                 0 2 0 4;
%                 0 0 0 0;
%                 0 0 0 0;
%                 0 2 0 4;
%                 0 0 0 0;]
zeromatrix = zeros(6,4);

% Your for-loop below

%% ... Yep, it's more for-loop

%Last one, I promise.
% Using only for loops and concatenation, take the 'value' below and build
% a 100x77 matrix where each element is the value of 'value'
% Hint: Remember that the colon can conveniently create a range? 
% Might be useful for doing this.
value = 3;

%// Your Loop Below


%% I lied, it's one more for-loop exercise.
%I'm giving you a value in 'value' below. In a for loop, I want you to
%count that value up according to this pattern:
% 1, 4, 9, 16, 25, 36... and so on.

%So if my value was 6, on every iteration it should go up like so:
% 6, LOOP START: 7, 11, 20, 36, 61, 97...

%I want what 'value' will be after 99 iterations.
value = 33;

%// Your code here

%//
%% Logical indexing

% Wait, why are we going back to indexing?
% Well, mostly because the ability to logically index is one of the most
% powerful things Matlab can do. 

%Before, we indexed by asking values at certain positions. For example, if I
%want the fifth and 7th values in the first row of my 'indexmatrix' I
%could type:
indexmatrix(1, [5 7])

%But another way I could do this is with a list of True and False values.
% Here's how this works. Let's consider a new 'myvector' below:
myvector = [1 9 3 7 8 6];

%I can build an equally sized vector made of True (1) and False (0)--
logicalvector = [0 0 1 1 1 0];
%Matlab thinks the 0s and 1s above are NUMBERS, so I have to specify
%they're actually True/False values below:
logicalvector = logical(logicalvector); 

%Okay, now watch this. Try evaluating the command below:
myvector(logicalvector)

%If you notice, this index operation pulled out every value where there was
%a True in my logical vector. The 3rd, 4th, and 5th values were all pulled
%out. 

%Now we're going to take a quick detour to talk about boolean operations.
%By boolean operations, I just mean operations that output a True/False
%value.

%For example, the 'equals' operation in Matlab is ==
3 == 4 %This should be false when tried in your console
2 == 2 %This should be true

%In the same vein, the 'not equal' ~=
3 ~= 6 %This should be true
4 ~=4 %This should be false

%'Greater than'
5 > 2 %True
5 > 5 %false

%'Greater or equal to'
5 >= 5 %True
5 > 4 %False

%Same deal with 'less than', and 'less than or equal to'
5 < 7 %True
5 < 5 % False
5 <= 5 %True
5 <= 99 %True

%These boolean operations can also be done on whole matrices!
%So let's go back to our 'indexmatrix'
indexmatrix

%What happens when we run a Boolean operation?
indexmatrix >= 5

%Well, you get a big logical matrix where the positions of everything
%greater-or-equal to 5 in indexmatrix have a True value. You've basically
%just run the Boolean operation on every element in there.

%That's cool. But how do we loop this around to logical indexing?

%Let's say I want to pull out all values in indexmatrix that are bigger or
%equal to 5...
indexmatrix(indexmatrix >= 5)

%Boom. Done. Very useful.

%ASSIGNMENT:
%Make the zerovector look like the one below, using only logical indexing.
%Try to do this in one line of code--that's how powerful logical indexing 
%can be.
%   zeromatrix = [0 0 0 0;
%                 0 0 0 0;
%                 0 0 0 0;
%                 0 5 5 0;
%                 0 5 5 0;
%                 0 5 5 0;]
zeromatrix = zeros(6,4);

%% Actual data. 
%This is what you've been waiting for. 
%First I want to clear all the variables we've been messing with so far:
clear all %Clears all variables
clc %clears the console to clean it up

%I'm going to load some data now--it's Rishabh's, actually.
%Make sure the files I sent are in the Matlab path so the following 
%commands work.
load('RKumar_Oddball_(000).mat')

%Ignore these below commands for a bit
eyedata = list{'Eye'}{'Left'};
eyedata = eyedata(:,3);
eyetime = list{'Eye'}{'Time'};
playtimes = list{'Stimulus'}{'Playtimes'};
playfreqs = list{'Stimulus'}{'Playfreqs'};
standardfreq = list{'Stimulus'}{'StandardFreq'};
oddfreq = list{'Stimulus'}{'OddFreq'};

%Okay, so here's some background on what this data is.
%THE EXPERIMENT:
%This is an Audio Oddball Task. What that means is--a participant listens
%to a series of tones. One is a standard frequency tone that plays 75% of
%the time, and then 25% of the time, an oddball frequency tone will play
%that is completely different!

%We are looking at pupil responses to this tone.
%Pupil dilation data is stored in the variable 'eyedata'. Each sample
%represents how dilated the eye is at that point in time, in millimeters.
eyedata;

%The timestamp of EACH sample of eyedata collected is in 'eyetime'.
%Here's how to think about this: the first datapoint in 'eyedata' was
%collected at the time specified by the first data point in 'eyetime'.
%In the same vein, the 77th data point in 'eyedata' was collected at the
%time specified by the 77th datapoint in 'eyetime'
eyetime;

%The timestamps when a sound is played (regardless of whether it is
%standard frequency or odd frequency) is in 'playtimes'
playtimes;

%The frequency of each sound played is in 'playfreqs'
playfreqs;

%The actual Standard Frequency is:
standardfreq;

%The odd frequency played is:
oddfreq;

%ASSIGNMENT:
%Eyetracker timestamps are in microseconds, but 'playtimes' is in regular
%old seconds. How can you convert 'playtimes' to all be in microseconds?

%HINT: Remember how Boolean operations were done on each element in a
%matrix? Well, it works the same way with arithmetic operations...

%// Your code here.

%//

%% Plotting
%Matlab is super useful for plotting. And you should be plotting
%frequently, because looking at a graph is often the best way to make sense
%of long vectors (it's hard to visualize just by looking at a list of
%numbers)

%Here's how to plot eyedata vs. eyetime
plot(eyedata, eyetime)

%Yup. It's that easy. I can also plot in red...
plot(eyedata, eyetime, 'r')
%Alternatively, the more verbose but more flexible way:
plot(eyedata, eyetime, 'Color', [1 0 0]) %That last vector specifies RGB values from 0 to 1. I made 'red' a 1

%I can also change whether it's a line I'm plotting or a series of circles
plot(eyedata, eyetime, 'o')
%Red circles...
plot(eyedata, eyetime, 'ro')
%Red stars?
plot(eyedata, eyetime, 'r*')

%There's a lot you can do. Look up matlab plotting options on Google and
%you'll get a good picture. 

%% Timestamps
%We know when sounds are being played, but we need to figure out what
%samples of eye data were collected DURING a sound.

%In other words, how do we get the indices of eyetracker data where a sound
%was played during time of collection?

%Some helpful functions are listed below. Type 'help [function name]' in
%the console to get a breakdown of what they do.
% length()
% max()
% min()
% find()

%This one will take some thinking. It will also need some kind of
%iteration, like with a for-loop.

%Discuss it, help each other out. Ask me
%questions and float ideas frequently--there are probably a ton of ways to
%solve this problem, and you might surprise me with one I've never tried!

%Frequently google to see if there are methods to try out your ideas, too.

%% Averages
%Let me tell you about the mean() function.
myvector = [1 3 5 7 9];

%On a vector like this, it'll do what you expect: take the average of the
%values in the vector. Try evaluating it and see if it matches your
%expectations.
mean(myvector)

%On matrices, it gets a lot cooler. So let's make a matrix--since I'm lazy,
%I'm just going to stack a bunch of these vectors on top of each other.
mymatrix = [myvector; myvector; myvector];

%Now let's try doing a mean on this
mean(mymatrix)

%Awesome. What it did was take the mean along the columns! But what if you
%wanted to take the mean along the rows?
mean(mymatrix, 2) %The two is specifying I want to mean along the second dimension: columns

%Boom. Done.

%Now that we know that... it might be useful to get the average pupil
%response to a sound!

%So you know where in the eyedata sounds are played. I want you to collect
%90 samples of post-stimulus data for every stimulus played. This should be
%in the form of a 300x90 matrix--each row will be one distinct stimulus,
%and the 90 columns will be eyedata collected after that stimulus.

%This may take some thought. Again, discuss, ask me questions, and float
%many many ideas.

%//Your code here

%//

%% Moving average
%You might have noticed that the eyedata is actually a little noisy. One
%really coarse way to smooth it out is by taking a moving average. That
%means that isntead of taking the raw values in a vector, I smooth it by
%replacing each value with the average of it and some neighboring values.

%Let's look at 'longvector' below.
longvector = [1 3 2 4 5 3 6 7 5 7 8 9 7 10 15 12 11 14 9 16 17 13 16 13 18 ...
               25, 22, 23, 22, 24, 27, 26, 29, 30, 31, 32, 27, 34, 28, 32];
           
%Try plotting it. It looks like a really noisy ascent, right? So let's
%manually do a moving average to get it smoother. 

averagedvector = []; %this is empty for now.

%I'm going to a use a window of 5 values, and each time, I will shift that 
%window to the right 1 time. If that doesn't make any sense, it will in a
%second.

%Okay, so the first value is 1. I want to take a window of 5 values with 1 
%at the center. To its left, there isn't anything there, so really I'm just 
%taking a window three values long, which looks like [1 2 3]. Then I'll
%take the mean, and have that as my new first value in the averagedvector
%vector.

averagedvector(1) = mean([1 3 2]);

%I do the same deal for the second value...
averagedvector(2) = mean([1 3 2 4]);

%And the third. At this point I can actually take a full 5 value window
%since I'm no longer at a boundary.


