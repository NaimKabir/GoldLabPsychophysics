function frameModelReview(dataFileName, doReprocess)
% load and plot results from frameModel* verification tests

if nargin < 2
    doReprocess = false;
end

load(dataFileName)

% may want to reprocess raw HID data, since I changed some of the code
if doReprocess
    [chans, volts, times, uints] = aIn.getScanWaveform();
    lightData.chans = chans;
    lightData.volts = volts;
    lightData.times = times;
    lightData.uints = uints;
end

% plot frame-by-frame swap timing data
f = figure('Name', dataFileName);
axSwap = subplot(2, 1, 1, 'Parent', f);
[swapOnset, swapColor, swapDrew] = plotSwaps(axSwap, gauge, timeData, colors);

% plot frame-by-frame light readings
axLight = subplot(4, 1, 3, ...
    'Parent', f, ...
    'XLim', get(axSwap, 'XLim'), ...
    'XTick', get(axSwap, 'XTick'), ...
    'XTickLabel', get(axSwap, 'XTickLabel'), ...
    'XGrid', get(axSwap, 'XGrid'));
[lightOnset, lightColor] = plotLight(axLight, gauge, timeData, lightData, colors);

% compare frame-by-frame timing and colors
axVerify = subplot(4, 1, 4, ...
    'Parent', f, ...
    'XLim', get(axSwap, 'XLim'), ...
    'XTick', get(axSwap, 'XTick'), ...
    'XTickLabel', get(axSwap, 'XTickLabel'), ...
    'XGrid', get(axSwap, 'XGrid'));
plotVerify(axVerify, gauge, swapOnset, swapColor, swapDrew, lightOnset, lightColor);
xlabel(axVerify, 'modeled frame number');

function [onsetTime frameColor, drewTime] = ...
    plotSwaps(axSwap, gauge, timeData, colors)
yLim = [0, timeData.nFrames+1];
zero = gauge.timeOfFrame(0);

swapLim = [ ...
    timeData.startTime(1) - gauge.framePeriod, ...
    timeData.onsetTime(end) + 3*gauge.framePeriod] - zero;
lastOnsetFrame = gauge.frameAtTime( ...
    timeData.onsetTime(end) + gauge.framePadding);
swapTick = gauge.timeOfFrame(0:lastOnsetFrame) - zero;
swapLabel = 0:lastOnsetFrame;
set(axSwap, ...
    'YLim', yLim, ...
    'YTick', [], ...
    'YGrid', 'off', ...
    'YTickLabel', [], ...
    'XLim', swapLim, ...
    'XTick', swapTick, ...
    'XTickLabel', swapLabel, ...
    'XGrid', 'on');
title(axSwap, func2str(timeData.swapFunction));
ylabel(axSwap, 'trial');

% show the swap timing per trial
y = 0;
yOffset = 1;
for ii = 1:timeData.nFrames
    
    % swap timing, color-coded by drawn frame color
    y = y + yOffset;
    col = colors(ii,:);
    start = timeData.startTime(ii);
    line(start-zero, y, ...
        'Parent', axSwap, ...
        'Color', col, ...
        'MarkerFaceColor', col, ...
        'Marker', '>', ...
        'LineStyle', 'none');
    delay = timeData.delayedTime(ii);
    line([start delay]-zero, [1 1]*y, ...
        'Parent', axSwap, ...
        'Color', [0 .6 0], ...
        'Marker', 'none', ...
        'LineStyle', '-');
    draw = timeData.drewTime(ii);
    line([delay draw]-zero, [1 1]*y, ...
        'Parent', axSwap, ...
        'Color', [.8 0 0], ...
        'Marker', 'none', ...
        'LineStyle', '-');
    swap = timeData.swappedTime(ii);
    line([draw swap]-zero, [1 1]*y, ...
        'Parent', axSwap, ...
        'Color', [0 .9 .9], ...
        'Marker', 'none', ...
        'LineStyle', '-');
    finish = timeData.finishTime(ii);
    onset = timeData.onsetTime(ii);
    onsetLines(ii) = line([finish onset]-zero, [1 1]*y, ...
        'Parent', axSwap, ...
        'Color', [0 0 1], ...
        'Marker', 'none', ...
        'LineStyle', ':');
    %     persistence = onset + gauge.framePeriod;
    %     line([onset persistence]-zero, [1 1]*y, ...
    %         'Parent', axSwap, ...
    %         'Color', col, ...
    %         'Marker', 'none', ...
    %         'LineWidth', 2, ...
    %         'LineStyle', '-');
    line(onset-zero, y, ...
        'Parent', axSwap, ...
        'Color', col, ...
        'MarkerFaceColor', col, ...
        'Marker', '<', ...
        'LineStyle', 'none');
end

names = { ...
    'trial start', ...
    'delay', ...
    'draw', ...
    'system swap', ...
    'predicted onset', ...
    'expected color', ...
    };
legend(axSwap, names{:}, 'Location', 'northwest');

onsetTime = timeData.onsetTime;
frameColor = colors;
drewTime = timeData.drewTime;


function [onsetTime frameColor] = plotLight(axLight, gauge, timeData, lightData, colors)
if numel(lightData.volts) < 1
    return
end

zero = gauge.timeOfFrame(0);

ylabel(axLight, 'light reading (V)');

% show all light measurements in the background
line(lightData.times-zero, lightData.volts, ...
    'Parent', axLight, ...
    'Color', [1 .5 .1], ...
    'Marker', '.', ...
    'LineStyle', 'none');

% locate the peak light readings per frame
%   limit to readings during frame swapping
%   limit to peaks above an arbitrary threshold
frameSeparation = 0.8*gauge.framePeriod;
sampleInterval = mode(diff(lightData.times));
sampleSeparation = ceil(frameSeparation/sampleInterval);
frameMinumum = .1;
[vPeak, iiPeak] = ...
    findpeaks(lightData.volts, ...
    'minpeakdistance', sampleSeparation, ...
    'minpeakheight', frameMinumum);
isFramePeak = false(1, numel(lightData.times));
isFramePeak(iiPeak) = true;
minPeakTime = min(timeData.onsetTime);
isFramePeak(lightData.times < minPeakTime) = false;
maxPeakTime = max(timeData.onsetTime) + gauge.framePeriod;
isFramePeak(lightData.times > maxPeakTime) = false;

% try to map light peaks on to frame colors
%   assume colors are gray and well-separated by light reading
%   group peaks by percentile
%   assign colors by nearness-to-group
grays = sort(unique(colors, 'rows'));
nGrays = size(grays, 1);
percentiles = linspace(0, 100, nGrays);
vGroup = prctile(lightData.volts(isFramePeak), percentiles);
set(axLight, ...
    'YTick', unique(vGroup), ...
    'YGrid', 'on');
nOnsetLines = 0;
onsetTime = zeros(1, sum(isFramePeak));
frameColor = zeros(sum(isFramePeak), 3);
for ii = find(isFramePeak)
    vFramePeak = lightData.volts(ii);
    tFramePeak = lightData.times(ii);
    [nearness, iiGroup] = min(abs(vGroup - vFramePeak));
    cFramePeak = grays(iiGroup, :);
    nOnsetLines = nOnsetLines + 1;
    onsetLines(nOnsetLines) = line(tFramePeak-zero, vFramePeak, ...
        'Parent', axLight, ...
        'Color', cFramePeak, ...
        'MarkerFaceColor', cFramePeak, ...
        'Marker', '^', ...
        'LineStyle', 'none');
    onsetTime(nOnsetLines) = tFramePeak;
    frameColor(nOnsetLines,:) = cFramePeak;
end

names = { ...
    'light reading', ...
    'peak color', ...
    };
legend(axLight, names{:}, 'Location', 'southwest');


function plotVerify(axVerify, gauge, swapOnset, swapColor, swapDrew, ...
    lightOnset, lightColor)
zero = gauge.timeOfFrame(0);

nSwaps = numel(swapOnset);
isCorrect = false(1, nSwaps);
earliness = swapOnset-swapDrew;
for ii = 1:nSwaps
    % how long between draw time and expected onset?
    line(swapOnset(ii)-zero, earliness(ii), ...
        'Parent', axVerify, ...
        'Color', swapColor(ii,:), ...
        'MarkerFaceColor', swapColor(ii,:), ...
        'Marker', '<', ...
        'LineStyle', 'none');
    
    % when was the next light peak following draw time?
    iiPeak = find(lightOnset > swapOnset(ii), 1, 'first');
    line(lightOnset(iiPeak)-zero, earliness(ii), ...
        'Parent', axVerify, ...
        'Color', lightColor(iiPeak,:), ...
        'MarkerFaceColor', lightColor(iiPeak,:), ...
        'Marker', '^', ...
        'LineStyle', 'none');
    
    % compare the predicted and measured colors and onset times
    isCorrect(ii) = isequal(swapColor(ii,:), lightColor(iiPeak,:)) ...
        && (lightOnset(iiPeak) - swapOnset(ii)) < gauge.framePeriod;
    if isCorrect(ii)
        compareColor = swapColor(ii,:);
    else
        compareColor = [1 0 0];
    end
    line([swapOnset(ii) lightOnset(iiPeak)]-zero, [1 1]*earliness(ii), ...
        'Parent', axVerify, ...
        'Color', compareColor, ...
        'Marker', 'none', ...
        'LineStyle', '-');
end

% choose tick marks to emphasize incorrect model predictions
yTicks = unique([ ...
    0, ...
    earliness(~isCorrect), ...
    min(earliness), ...
    max(earliness)]);
set(axVerify, ...
    'YTick', yTicks, ...
    'YGrid', 'on');
ylabel(axVerify, 'earliness (s)');

names = { ...
    'expected color', ...
    'peak color'};
legend(axVerify, names{:}, 'Location', 'southeast');